LC-64
class Solution {
    public int minPathSum(int[][] grid) {
      int rows=grid.length;
      int cols=grid[0].length;
      int[][] dirs= {{1,0},{0,1}};
        int[][] minDist = new int[rows][cols];
        for(int[]r:minDist){
            Arrays.fill(r,Integer.MAX_VALUE);
        }
        minDist[0][0]=grid[0][0];
        PriorityQueue<int[]> pq= new PriorityQueue<>((a,b)->a[2]-b[2]);
        pq.offer(new int[]{0,0,grid[0][0]});
        while(!pq.isEmpty()){
            int[] curr = pq.poll();
            int r=curr[0], c=curr[1], dist=curr[2];
            if(dist>minDist[r][c]) continue;
            if(r==rows-1 && c==cols-1) return dist;
             for(int[]d:dirs){
            int nr=r+d[0];
            int nc=c+d[1];
            if(nr>=0 && nc>=0 && nr<rows && nc<cols){
                int newDist=dist+grid[nr][nc];
                if(newDist<minDist[nr][nc]){
                    minDist[nr][nc]=newDist;
                    pq.offer(new int[]{nr,nc,newDist});
                }
            }
            }
        }
        return minDist[rows-1][cols-1];
    }
}

dp

class Solution {
    public int minPathSum(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                if (r == 0 && c == 0) continue;
                if (r == 0) {
                    grid[r][c] += grid[r][c - 1];
                } else if (c == 0) {
                    grid[r][c] += grid[r - 1][c];
                } else {
                    grid[r][c] += Math.min(grid[r - 1][c], grid[r][c - 1]);
                }
            }
        }
        return grid[rows - 1][cols - 1];
    }
}