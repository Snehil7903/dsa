Kth Symbol in Grammar

int solve (int n, int k){
    if(n==1 && k==1) return 0;
    int mid = Math.pow(2,n-1)/2;
    if(k<=mid){
        return solve(n-1,k);
    }
    else{
        return !solve(n-1,k-mid);
    }
}



public class KthGrammar {

    public static void main(String[] args) {
        // Example: n=4, k=3
        // Row 1: 0
        // Row 2: 01
        // Row 3: 0110
        // Row 4: 01101001 -> The 3rd element is 1
        System.out.println("Result: " + solve(4, 3)); 
    }

    public static int solve(int n, int k) {
        // Base case: The first row is always 0
        if (n == 1 && k == 1) {
            return 0;
        }

        // Calculate mid: The length of row n is 2^(n-1). 
        // Mid is half of that: 2^(n-2).
        int mid = (int) Math.pow(2, n - 1) / 2;

        if (k <= mid) {
            // First half: exactly the same as the previous row
            return solve(n - 1, k);
        } else {
            // Second half: the complement (flipped) of the previous row
            // In Java, we flip 0/1 using: 1 - value
            return 1 - solve(n - 1, k - mid);
        }
    }
}




Using Bit Manipulation
public static int solve(int n, int k) {
    // Base case: Row 1 is always just 0
    if (n == 1) {
        return 0;
    }

    // The length of row n is 2^(n-1). 
    // The midpoint is 2^(n-2).
    // Using (1 << (n-2)) is efficient for powers of 2.
    int mid = 1 << (n - 2);

    if (k <= mid) {
        // If k is in the first half, it's identical to the same position in row n-1
        return solve(n - 1, k);
    } else {
        // If k is in the second half, it's the complement of (k - mid) in row n-1
        return 1 - solve(n - 1, k - mid);
    }
}