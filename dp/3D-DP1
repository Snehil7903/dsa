lc3651
3D dp

class Solution {
    public int minCost(int[][] grid, int k) {
        int m = grid.length, n = grid[0].length;
        int INF = Integer.MAX_VALUE / 2;
        
        int[][][] dp = new int[k + 1][m][n];
        for (int t = 0; t <= k; t++) {
            for (int i = 0; i < m; i++) Arrays.fill(dp[t][i], INF);
        }

        dp[0][0][0] = 0;
        updateLayer(dp[0], grid, m, n);

        TreeMap<Integer, List<int[]>> valueToPos = new TreeMap<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                valueToPos.computeIfAbsent(grid[i][j], z -> new ArrayList<>()).add(new int[]{i, j});
            }
        }

        List<Integer> sortedValues = new ArrayList<>(valueToPos.keySet());
        Collections.sort(sortedValues, Collections.reverseOrder());

        for (int t = 1; t <= k; t++) {
            int currentBestSourceCost = INF;
            
            for (int val : sortedValues) {

                for (int[] pos : valueToPos.get(val)) {
                    currentBestSourceCost = Math.min(currentBestSourceCost, dp[t - 1][pos[0]][pos[1]]);
                }
                
                for (int[] pos : valueToPos.get(val)) {
                    dp[t][pos[0]][pos[1]] = currentBestSourceCost;
                }
            }
            
            updateLayer(dp[t], grid, m, n);
        }

        int ans = INF;
        for (int t = 0; t <= k; t++) {
            ans = Math.min(ans, dp[t][m - 1][n - 1]);
        }
        
        return ans >= INF ? -1 : ans;
    }

    private void updateLayer(int[][] layer, int[][] grid, int m, int n) {
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i > 0) layer[i][j] = Math.min(layer[i][j], layer[i - 1][j] + grid[i][j]);
                if (j > 0) layer[i][j] = Math.min(layer[i][j], layer[i][j - 1] + grid[i][j]);
            }
        }
    }
}